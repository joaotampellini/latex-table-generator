<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LaTeX Table Generator (Custom Clines)</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #fcfcfc; }
    h1 { margin-bottom: 10px; }
    .controls { margin-bottom: 15px; }
    button { margin-right: 5px; padding: 5px 10px; }
    .editor-table { border-collapse: collapse; margin-bottom: 15px; position: relative; }
    .editor-table td {
      border: 1px solid #aaa;
      padding: 10px;
      min-width: 100px;
      text-align: center;
      cursor: pointer;
      position: relative;
    }
    .line-slot-row td {
      padding: 0;
      line-height: 1;
      height: 5px;
      background: transparent;
      position: relative;
      cursor: pointer;
    }
    .line-slot-row td.active {
      background-color: black !important;
    }
    .line-popup {
      position: absolute;
      top: -70px;
      left: 10px;
      background: white;
      border: 1px solid #aaa;
      font-size: 12px;
      z-index: 10;
      padding: 5px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .line-popup div {
      padding: 4px 8px;
      cursor: pointer;
    }
    .line-popup div:hover {
      background: #eee;
    }
    .alignment-row td {
      background: #f7f7f7;
      font-size: 12px;
      cursor: pointer;
      padding: 3px;
    }
    .output-box {
      background: #f0f0f0;
      padding: 10px;
      white-space: pre-wrap;
      border: 1px solid #ccc;
    }
    #notesBox {
      margin-top: 10px;
      display: none;
    }
    #notesTextarea {
      width: 100%;
      height: 60px;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <h1>LaTeX Table Generator</h1>
  <div id="authorInfo" style="margin-bottom: 15px; font-size: 14px; color: #666;">
  Created by João Tampellini for personal academic use. </br>
  Department of Economics, Vanderbilt Unviersity </br>
  © 2025. Licensed under CC BY-NC 4.0.   </br>
  </div>

  <div class="controls">
    <span style="margin-right: 15px;">
      <button onclick="addRow()">+ Row</button>
      <button onclick="removeRow()">- Row</button>
    </span>
    <span style="margin-right: 15px;">
      <button onclick="addColumn()">+ Column</button>
      <button onclick="removeColumn()">- Column</button>
    </span>
    <label><input type="checkbox" id="booktabsToggle" onchange="redrawFromState()" checked> Use booktabs (recommended)</label>
    <label><input type="checkbox" id="alignmentToggle" onchange="redrawFromState()"> Show alignment settings</label>
    <label><input type="checkbox" id="adjustboxToggle" onchange="generateLatex()"> Table too wide?</label>
    <label><input type="checkbox" id="econStyleToggle" onchange="applyEconStyle()"> Econ style</label>
  </div>
  <label><input type="checkbox" id="floatToggle" onchange="toggleFloatBox()"> Show float specifier</label><br>
  <div id="floatBox" style="display: none;">
    Float specifier:
    <input type="text" id="floatInput" value="htbp!" style="width: 80px; margin-bottom: 5px;">
    <div style="font-size: 12px; color: #555; margin-top: 2px;">
      <strong>Float options:</strong><br>
      <code>H</code>: HERE (strongly), <code>h</code>: here, <code>t</code>: top, <code>b</code>: bottom, <code>p</code>: page, <code>!</code>: override LaTeX placement rules<br>
      <code>H</code> cannot be combined with other options.
    </div>
  </div>
  <label>Table title: <input type="text" id="tableTitle" style="width: 300px;"></label><br>
  <label>Table label: <input type="text" id="tableLabel" value="\label{tab:name}" style="width: 300px;"></label>

  <table id="editor" class="editor-table"></table>

  <label><input type="checkbox" id="addNotesToggle" onchange="toggleNotesBox()"> Add table notes</label>
  <div id="notesBox">
    <textarea id="notesTextarea">\item \textit{Notes:} *** $p$<0.01, ** $p$<0.05, * $p$<0.10</textarea>
  </div>

  <button onclick="generateLatex()">Generate LaTeX</button>
  <h3>LaTeX Output:</h3>
  <pre id="output" class="output-box"></pre>

  <script>
    let rows = 4;
    let cols = 4;
    let colAlignments = Array.from({ length: cols }, (_, i) => i === 0 ? "l" : "c");
    let lineStates = {};

    function applyEconStyle() {
      const checked = document.getElementById("econStyleToggle").checked;
      if (!checked) return;  // Only act if enabled

      // Reset lineStates and set Econ-style lines
      lineStates = {
        0: { type: 'toprule' },
        1: { type: 'midrule' },
        2: { type: 'midrule' },
        [rows]: { type: 'bottomrule' }
      };

      // Add column headers (1), (2), etc. to second row except the first column
      const editor = document.getElementById("editor");
      const alignOffset = document.getElementById("alignmentToggle").checked ? 1 : 0;
      const headerRow = editor.querySelectorAll("tr")[1 + alignOffset];  // First content row
      const secondRow = editor.querySelectorAll("tr")[3 + alignOffset];  // Second content row

      if (secondRow) {
        const cells = secondRow.querySelectorAll("td");
        for (let c = 0; c < cells.length; c++) {
          if (c === 0) continue;
          cells[c].innerText = `(${c})`;
        }
      }

      redrawFromState();
    }

    function setDefaultLines() {
      lineStates = {
        0: { type: 'toprule' },
        1: { type: 'midrule' },
        [rows]: { type: 'bottomrule' }
      };
    }

    function toggleFloatBox() {
      const box = document.getElementById("floatBox");
      box.style.display = document.getElementById("floatToggle").checked ? "block" : "none";
      generateLatex();
    }
    function toggleNotesBox() {
      const box = document.getElementById("notesBox");
      box.style.display = document.getElementById("addNotesToggle").checked ? "block" : "none";
      generateLatex();
    }

    function captureTableState() {
      const data = [];
      const rowEls = Array.from(document.querySelectorAll("#editor tr")).filter((_, i) => i % 2 !== 0);
      rowEls.forEach(row => {
        const rowData = [];
        Array.from(row.cells).forEach(cell => {
          rowData.push({ content: cell.innerText, align: cell.dataset.align });
        });
        data.push(rowData);
      });
      return { data, colAlignments: [...colAlignments], hasLineStates: Object.keys(lineStates).length > 0 };
    }

    function redrawFromState() {
      const saved = captureTableState();
      buildTable(saved);
    }

    function mergeConsecutive(arr) {
      arr.sort((a, b) => a - b);
      const result = [];
      let start = arr[0];
      let prev = arr[0];
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] === prev + 1) {
          prev = arr[i];
        } else {
          result.push([start, prev]);
          start = prev = arr[i];
        }
      }
      result.push([start, prev]);
      return result;
    }

    function showLinePopup(event, rowIndex, cell) {
      const existing = document.querySelector(".line-popup");
      if (existing) existing.remove();

      const popup = document.createElement("div");
      popup.className = "line-popup";
      const useBooktabs = document.getElementById("booktabsToggle").checked;
      const isFullRow = rowIndex === 0 ? "toprule" :
                        rowIndex === rows ? "bottomrule" :
                        useBooktabs ? "midrule" : "hline";

      ["none", isFullRow, "custom cline"].forEach(opt => {
        const div = document.createElement("div");
        div.innerText = opt;
        div.onclick = (e) => {
          e.stopPropagation();
          if (opt === "none") {
            delete lineStates[rowIndex];
          } else if (opt === "custom cline") {
            lineStates[rowIndex] = { type: "cline", cols: [] };
          } else {
            lineStates[rowIndex] = { type: opt };
          }
          popup.remove();
          redrawFromState();
        };
        popup.appendChild(div);
      });

      cell.appendChild(popup);
      popup.onclick = (e) => e.stopPropagation();
    }

    function buildTable(saved = null) {
      if (!saved?.hasLineStates) setDefaultLines();

      const table = document.getElementById("editor");
      table.innerHTML = "";
      if (saved?.colAlignments) colAlignments = [...saved.colAlignments];

      if (document.getElementById("alignmentToggle").checked) {
        const alignRow = document.createElement("tr");
        alignRow.className = "alignment-row";
        for (let c = 0; c < cols; c++) {
          const td = document.createElement("td");
          td.innerText = colAlignments[c].toUpperCase();
          td.onclick = () => {
            const order = ["l", "c", "r"];
            colAlignments[c] = order[(order.indexOf(colAlignments[c]) + 1) % 3];
            redrawFromState();
          };
          alignRow.appendChild(td);
        }
        table.appendChild(alignRow);
      }

      for (let r = 0; r <= rows; r++) {
        const lineRow = document.createElement("tr");
        lineRow.className = "line-slot-row";

        const line = lineStates[r];
        if (line?.type === "cline") {
          for (let c = 0; c < cols; c++) {
            const td = document.createElement("td");
            td.dataset.row = r;
            td.dataset.col = c + 1;
            td.className = line.cols.includes(c + 1) ? "active" : "";
            td.onclick = () => {
              const colNum = c + 1;
              const idx = line.cols.indexOf(colNum);
              if (idx >= 0) {
                line.cols.splice(idx, 1);
              } else {
                line.cols.push(colNum);
              }
              // Auto convert to full line
              const fullRow = Array.from({ length: cols }, (_, i) => i + 1);
              const isFull = fullRow.every(n => line.cols.includes(n));
              if (isFull) {
                const useBooktabs = document.getElementById("booktabsToggle").checked;
                lineStates[r] = {
                  type: r === 0 ? "toprule" : r === rows ? "bottomrule" : (useBooktabs ? "midrule" : "hline")
                };
              }
              redrawFromState();
            };
            lineRow.appendChild(td);
          }
        } else {
          const td = document.createElement("td");
          td.colSpan = cols;
          td.dataset.row = r;
          if (["toprule", "midrule", "bottomrule", "hline"].includes(line?.type)) {
            td.className = "active";
          }
          td.onclick = (e) => showLinePopup(e, r, td);
          lineRow.appendChild(td);
        }
        table.appendChild(lineRow);

        if (r < rows) {
          const row = document.createElement("tr");
          for (let c = 0; c < cols; c++) {
            const cell = document.createElement("td");
            const content = saved?.data?.[r]?.[c]?.content || "";
            const align = saved?.data?.[r]?.[c]?.align || colAlignments[c];
            cell.contentEditable = true;
            cell.innerText = content;
            cell.dataset.align = align;
            cell.style.textAlign = align === "l" ? "left" : align === "r" ? "right" : "center";
            row.appendChild(cell);
          }
          table.appendChild(row);
        }
      }
      generateLatex();
    }

    function generateLatex() {
      const useBooktabs = document.getElementById("booktabsToggle").checked;
      const addNotes = document.getElementById("addNotesToggle").checked;
      const notes = document.getElementById("notesTextarea").value.trim();
      const caption = document.getElementById("tableTitle").value.trim();
      const label = document.getElementById("tableLabel").value.trim();
      const useAdjustbox = document.getElementById("adjustboxToggle").checked;

      const colSpec = useBooktabs ? colAlignments.join("") : "|" + colAlignments.join("|") + "|";
      let latex = "";
      if (useBooktabs) latex += "% \\usepackage{booktabs}  % remove % to activate if not already in preamble\n";
      if (addNotes)    latex += "% \\usepackage{threeparttable}  % remove % to activate if not already in preamble\n";
      if (useAdjustbox) latex += "% \\usepackage{adjustbox}  % remove % to activate if not already in preamble\n";
      latex += "\n";

      const floatSpec = document.getElementById("floatToggle").checked
        ? document.getElementById("floatInput").value.trim()
        : "htbp!";

      latex += `\\begin{table}[${floatSpec}]\\centering\n`;
      if (addNotes) latex += "\\begin{threeparttable}\n";
      if (caption) latex += `\\caption{${caption}}\n`;
      if (label) latex += `${label}\n`;
      if (useAdjustbox) latex += `\\begin{adjustbox}{width=\\textwidth}\n`;
      latex += `\\begin{tabular}{${colSpec}}\n`;      

      const editor = document.getElementById("editor");
      const allRows = Array.from(editor.querySelectorAll("tr"));
      const alignOffset = document.getElementById("alignmentToggle").checked ? 1 : 0;

      for (let r = 0; r <= rows; r++) {
        const line = lineStates[r];
        if (line) {
          if (line.type === "cline") {
            const sorted = line.cols.slice().sort((a, b) => a - b);
            let groups = [];
            let start = sorted[0], end = sorted[0];
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i] === end + 1) {
                end = sorted[i];
              } else {
                groups.push([start, end]);
                start = end = sorted[i];
              }
            }
            groups.push([start, end]);
            groups.forEach(([s, e]) => {
              latex += `\\cline{${s}-${e}}\n`;
            });
          } else {
            latex += `\\${line.type}\n`;
          }
        }

        if (r < rows) {
          const contentRowIndex = r * 2 + 1 + alignOffset;
          const contentRow = allRows[contentRowIndex];
          const cells = Array.from(contentRow.cells).map(cell => cell.innerText.trim());
          latex += cells.join(" & ") + " \\\n";
        }
      }

      latex += "\\end{tabular}\n";
      if (addNotes) latex += `\\begin{tablenotes}[flushleft]\\footnotesize\n${notes}\n\\end{tablenotes}\n\\end{threeparttable}\n`;
      if (useAdjustbox) latex += "\\end{adjustbox}\n";
      latex += "\\end{table}";

      document.getElementById("output").textContent = latex;
    }

    function showLinePopup(event, rowIndex, cell) {
      const existing = document.querySelector(".line-popup");
      if (existing) existing.remove();

      const popup = document.createElement("div");
      popup.className = "line-popup";

      const useBooktabs = document.getElementById("booktabsToggle").checked;
      const fullLineLabel = rowIndex === 0 ? (useBooktabs ? 'toprule' : 'hline') :
                            rowIndex === rows ? (useBooktabs ? 'bottomrule' : 'hline') :
                            (useBooktabs ? 'midrule' : 'hline');

      ["none", fullLineLabel, "custom cline"].forEach(opt => {
        const div = document.createElement("div");
        div.innerText = opt;
        div.onclick = (e) => {
          e.stopPropagation();
          if (opt === "none") delete lineStates[rowIndex];
          else if (opt === "custom cline") lineStates[rowIndex] = { type: 'cline', cols: [] };
          else lineStates[rowIndex] = { type: opt };
          popup.remove();
          redrawFromState();
        };
        popup.appendChild(div);
      });

      cell.appendChild(popup);
      popup.onclick = (e) => e.stopPropagation();
    }

    function addRow() {
      rows++;
      lineStates[rows] = { type: 'bottomrule' }; // Move bottomrule down
      delete lineStates[rows - 1]; // Remove previous bottomrule
      redrawFromState();
    }

    function removeRow() {
      if (rows > 1) {
        delete lineStates[rows]; // Remove current bottomrule
        rows--;
        lineStates[rows] = { type: 'bottomrule' }; // Move bottomrule up
        redrawFromState();
      }
    }
    function addColumn() { cols++; colAlignments.push("c"); redrawFromState(); }
    function removeColumn() { if (cols > 1) { cols--; colAlignments.pop(); redrawFromState(); } }

    setDefaultLines();
    buildTable();
  </script>
</body>
</html>